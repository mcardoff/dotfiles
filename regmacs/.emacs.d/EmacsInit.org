#+STARTUP:OVERVIEW
My emacs config
* General Setup
** Package
This is required by default to initialize the packages and get the correct repos:
#+begin_src emacs-lisp
(require 'package)
(setq package-archives '(
      ("melpa" . "https://melpa.org/packages/")
      ("org" . "https://orgmode.org/elpa/")
      ("elpa" . "https://elpa.gnu.org/packages/")))
(package-initialize)

(unless package-archive-contents (package-refresh-contents))
#+end_src
 Now we have added melpa to our package archives and initialized packages.  We also want to use the use-package style, so we add use-package if it is not installed already
#+begin_src emacs-lisp
(unless (package-installed-p 'use-package) 
(package-install 'use-package))
#+end_src
Now we can configure it
#+begin_src emacs-lisp
(require 'use-package)
(setq use-package-always-demand 'ein)
(setq use-package-always-ensure t)
#+end_src
** Appearance
*** Aesthetics
This is just a few aesthetic changes that make emacs appear to be a lot cleaner
#+begin_src emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode 0)
(scroll-bar-mode 0)
(tooltip-mode 0)
(window-divider-mode)
(column-number-mode)
(show-paren-mode)
(fringe-mode 1)
(setq inhibit-startup-screen 1)
(setq visible-bell 1)
#+end_src
The last bit gets rid of the splash screen when you start emacs, and makes it so it does not make an annoying sound every time youre at the end of a file. This next part is what sets the font:
#+begin_src emacs-lisp
(set-face-attribute 'default nil :font "Source Code Pro" :height 140)
#+end_src
I want to try to use command log mode so I can see what I am doing when messing around with commands
#+begin_src emacs-lisp
(use-package command-log-mode)
#+end_src
*** Theme
I use the =gruber-darker= theme, which compliments emacs very well
#+begin_src emacs-lisp
(load-theme 'gruber-darker t)
#+end_src
*** Line Numbers
Here is the customization for line numbers, including the type
#+begin_src emacs-lisp
(global-display-line-numbers-mode)
(setq display-line-numbers-type t)
#+end_src
* Auto Mode File Bindings
Here is where we associate a particular type of file with a mode, by default emacs does not associate `.m` files with `octave-mode` so we have to tell emacs ourself:
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.m$" . octave-mode))
#+end_src
The same goes for `.org` files and `org-mode`
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
#+end_src
We also want to associate `.cu` with `cuda-mode`
#+begin_src emacs-lisp
  ;; (add-to-list 'auto-mode-alist '("\\.cu$" . cuda-mode))
#+end_src
* Keybindings
These are just some helpful general functions that make my life a little bit easier, with a table of all of them:
|---------+------------------------+------------------------|
| BINDING | DESCRIPTION            | FUNCTION               |
|---------+------------------------+------------------------|
| M-1     | Kill other windows     | `delete-other-windows` |
| M-2     | Split horizontally     | `split-window-below`   |
| M-3     | Split vertically       | `split-window-right`   |
| M-o     | Go to the other window | `other-window`         |
| M-r     | Enlarge current window | `enlarge-window 16`    |
| S-M-R   | Shrink current window  | `shrink-window 2`      |
| ESC     | Quit                   | `keyboard-escape-quit  |
|---------+------------------------+------------------------|
  
Here is the actual declaration of all of these
#+begin_src emacs-lisp
(defun enlarge-fun () (interactive) (enlarge-window 2))
(defun shrink-fun () (interactive) (shrink-window 2))
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'split-window-below)
(global-set-key (kbd "M-3") 'split-window-right)
(global-set-key (kbd "M-o") 'other-window)
(global-set-key (kbd "M-r") 'enlarge-fun)
(global-set-key (kbd "M-R") 'shrink-fun)
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src
* Programming Adjacent
** LaTeX-Mode
There are a couple things I like to have enabled with LaTeX mode as well, which make everything a little easier to see as well as edit:
#+begin_src emacs-lisp
(add-hook 'latex-mode-hook (lambda () (visual-line-mode 1)))
(add-hook 'latex-mode-hook (lambda () (outline-minor-mode 1)))
#+end_src
I have a few snippets available for latex-mode, made using yasnippet:
| SNIPPET  | DESCRIPTION                       |
|----------+-----------------------------------|
| qm       | 6 blank sections                  |
| probs    | 5 blank sections                  |
| frac     | fraction, prompts for inputs      |
| template | in progress, copies template file |
*** AUCTeX
Lets try setting up auctex
#+BEGIN_SRC emacs-lisp
    (use-package auctex
    :defer t
    :ensure t
    :custom
    (TeX-view-program-selection 
    '(((output-dvi has-no-display-manager) "dvi2tty") 
      ((output-dvi style-pstricks)  "dvips and gv")
       (output-dvi "xdvi")
       (output-pdf "Zathura")
       (output-html "xdg-open"))))

  (defun my/TeX-view-once (doc)
    "View TeX output and clean up after `my/TeX-compile-and-view'.

  Call `TeX-view' to display TeX output, and remove this function
  from `TeX-after-TeX-LaTeX-command-finished-hook', where it may
  have been placed by `my/TeX-compile-and-view'."
    (TeX-view)
    (remove-hook 'TeX-after-TeX-LaTeX-command-finished-hook #'my/TeX-view-once))


  (defun my/TeX-compile-and-view ()
    "Compile current master file using LaTeX then view output.

  Run the \"LaTeX\" command on the master file for active buffer.
  When compilation is complete, view output with default
  viewer (using `TeX-view')."
    (interactive)
    (TeX-command "LaTeX" 'TeX-master-file)
    (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook #'my/TeX-view-once))
#+END_SRC
** CUDA-Mode
#+begin_src emacs-lisp
  (use-package cuda-mode :ensure t)
#+end_src
** Emacs IPython
This is the jupyter config, but it does not really work for this purpose, it is more useful to do it in the actual .emacs file
#+BEGIN_SRC emacs-lisp
;;(require 'ein)
;;(ein:stop)
;;(use-package ein
;;:init
;;(set-face-attribute 'ein:cell-input-prompt 'nil :foreground "181818" :background "282828")
;;(set-face-attribute 'ein:cell-input-area 'nil :foreground "FFFFFF" :background "FFFFFF"))
#+END_SRC
** Projectile
Projectile is a project management package useful for bigger code projects
#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    ;; :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    (when (file-directory-p "~/Projects/Code")
      (setq projectile-project-search-path '("~/Projects/Code")))
    (setq projectile-switch-project-action #'projectile-dired))
#+end_src
There is some better integration with counsel with porjectile-counsel
#+begin_src emacs-lisp
(use-package counsel-projectile
  :after 'projectile
  :config (counsel-projectile-mode))
#+end_src
* Minibuffer Access
** ido-mode
Ido makes `find-file` and other similar functions look a lot nicer, and `smex` is the same but for `M-x`
#+begin_src emacs-lisp
;; (ido-mode 1)
;; (ido-everywhere 1)
;; 
;; (global-set-key (kbd "M-x") 'smex)
;; (global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+end_src
** Ivy Setup
Ivy is an alternative to ido, and I am just trying it out, so this is temporary, but may be fully integrated later
#+begin_src emacs-lisp
(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
         ("M-x" . counsel-M-x)
         ("C-h v" . counsel-describe-variable)
         ("C-x b" . ivy-switch-buffer)
         ("C-x C-f" . counsel-find-file)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)	
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill)))
#+end_src
It is sometimes useful to use =ivy-rich= for more useful info on commands and such
#+begin_src emacs-lisp
(use-package ivy-rich :diminish )
(ivy-rich-mode 1)
#+end_src
** Counsel
An addition to ivy is counsel, which makes use of x, we just need to have it installed!
#+begin_src emacs-lisp
(use-package counsel :diminish)
#+end_src
** All the icons ivy
This mode adds some bling to ivy and ivy-rich
#+begin_src emacs-lisp
(use-package all-the-icons-ivy
  :init (add-hook 'after-init-hook 'all-the-icons-ivy-setup))
(use-package all-the-icons-ivy-rich
  :ensure t
  :init (all-the-icons-ivy-rich-mode 1))
#+end_src
* Text Editing
** Multiple Cursors
Multiple cursors makes your life so much easier when you know how to use them. A helpful use case is you can search for something and place a cursor on each match for example. It helps a lot when heap editing files
#+begin_src emacs-lisp
(use-package multiple-cursors
:diminish
:bind (("C-S-c C-S-c" . mc/edit-lines)
       ("C->" . mc/mark-next-like-this)
	 ("C-<" . 'mc/mark-previous-like-this)
	 ("C-c C-<" . 'mc/mark-all-like-this)))
#+end_src
** Move Text
Similar idea to multiple cursors, this is just really helpful and  pretty much a necessary package
#+begin_src emacs-lisp
(use-package move-text
  :diminish 
  :bind (("M-p" . 'move-text-up)
         ("M-n" . 'move-text-down)))
#+end_src
* Modeline config
Speaking of the modeline, lets make it even more pretty with a couple of options! However, first we talk about Diminish, which cleans up the default modeline a bit
** Diminish
This mode makes it so you do not have any themes clogging up your mode line, and it looks oh so good
#+begin_src emacs-lisp
(use-package diminish)
(diminish 'org-bullets-mode)
(diminish 'visual-line-mode)
(diminish 'whitespace-mode)
(diminish 'yas-minor-mode)
(diminish 'hasklig-mode)
(diminish 'eldoc-mode)
#+end_src
** Powerline
In powerline, there are a couple different options for the various themes, I prefer the vim theme, which I use normally.
#+begin_src emacs-lisp
;;(powerline-vim-theme)
;; (powerline-default-theme)
;; (powerline-center-theme)
;; (powerline-nano-theme)
#+end_src
** Doom Modeline
If you are not keen on running any of the powerline themes, you can run doom-modeline, which is used in doom emacs! 
#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  :custom
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-height 25)
  (doom-modeline-icon t))
#+end_src
* Org
Org is a very nice note-taking mode in emacs, I like to have pretty bullets and I like to have the line highlighted when editing, hence the hook region.
  
Another useful feature is the agenda that is built in, we specify the directory in which we have our agenda files and a keybind that opens the agenda for easy access
  
I am also trying out something called org-alert, it is supposed to send you notifications about the items in your agenda. This comprises of the `requires` and `init` tags. 

Here I define a function to set up org mode, involving the different packages I like loaded whe I use org
#+begin_src emacs-lisp
(defun mpc/org-mode-setup ()
  (org-indent-mode)
  ;;(variable-pitch-mode 1)
  (visual-line-mode 1)
  (hl-line-mode 1))
#+end_src

Since I am trying to move everything to the `use-package` paradigm, here is the translation of all that into `use-package`
#+begin_src emacs-lisp
(use-package org
   :hook (org-mode . mpc/org-mode-setup)
   :config
   (setq org-ellipsis " [+]")
   (setq org-agenda-files "~/org/Test.org")
   (set-face-attribute 'org-ellipsis 'nil :underline 'nil :foreground "FFFFFF")
 )

 (use-package org-bullets
   :after org
   :hook (org-mode . org-bullets-mode))

 (defun mpc/org-mode-visual-fill ()
   (setq visual-fill-column-width 200
         visual-fill-column-center-text nil)
   (visual-fill-column-mode 1))

 (use-package visual-fill-column
   :hook (org-mode . mpc/org-mode-visual-fill))
#+end_src
** Org Roam
Currently my notes are all over the place, org roam should hopefully make that look nicer
* Email/mu4e
I am trying to get this set up, my mail is currently in ~/Mail and I am using offlineimap to index my email, now we will set it up on the emacs side:
#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :ensure nil
  :config
    (setq mu4e-change-filenames-when-moving t)
    (setq mu4e-update-interval (* 10 60))
    (setq mu4e-get-mail-command "offlineimap")
    (setq mu4e-maildir "~/Mail")

    (setq mu4e-drafts-folder "/[Gmail].Drafts")
    (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
    (setq mu4e-refile-folder "/[Gmail].All Mail")
    (setq mu4e-trash-folder  "/[Gmail].Trash")
    

    (setq mu4e-maildir-shortcuts
    '((:maildir "/INBOX"    :key ?i)
      (:maildir "/[Gmail].Sent Mail" :key ?s)
      (:maildir "/[Gmail].Trash"     :key ?t)
      (:maildir "/[Gmail].Drafts"    :key ?d)
      (:maildir "/[Gmail].All Mail"  :key ?a))))
      
#+END_SRC
* Dired
Dired is the emacs directory editor, I just need to customize a few things
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-lXGAh --group-directories-first")
#+END_SRC
* Snippets
Snippets will save your life when doing repetitive tasks, use them often and your life will be so much easier
#+begin_src emacs-lisp
  (use-package yasnippet)
  (setq yas-snippet-dirs '("~/.emacs.d/mysnippets"))
  (yas-global-mode)
#+end_src
* elfeed
=elfeed= is an rss reader, for now I use it for some subreddits that are mostly text based, images are possible just not what I require from this:
#+begin_src emacs-lisp
  (use-package elfeed
  :ensure t
  :custom
  (elfeed-feeds '("http://www.reddit.com/r/emacs/.rss"
                  "http://www.reddit.com/r/Physics/.rss")))
#+end_src
Lets try using some extra stuff using `elfeed-goodies`
#+begin_src emacs-lisp
  (use-package elfeed-goodies :ensure t)
#+end_src
* Doc View
For some reason `doc-view` did not work for me by default, so I had to change the install directory, that is the only reason for this section
#+begin_src emacs-lisp
  ;; (setq doc-view-ghostscript-program "C:/Program Files/gs/gs9.53.3/bin/gswin64c.exe")
#+end_src
This should only be on windows, hence why it is commented out here
* Outline
This mode is super useful when dealing with super long LaTeX files that have confusing structures. At first I had the keybinds set to weird keys, so I changed them to keys that seemed relatively unused
#+begin_src emacs-lisp
  ;; (use-package outline-minor-mode)
  (global-set-key (kbd "C-;") 'outline-hide-subtree)
  (global-set-key (kbd "C-:") 'outline-show-subtree)
  (global-set-key (kbd "C-'") 'outline-hide-entry)
  (global-set-key (kbd "C-\"") 'outline-show-entry)
#+end_src
** Extra Headers for LaTeX
   Like I said, my favorite use case for this mode is LaTeX documents,
   so it makes sense to outline the section headers in LaTeX:
   #+begin_src emacs-lisp
   (setq TeX-outline-extra
      '(("%chapter" 1)
        ("%section" 2)
        ("%subsection" 3)
        ("%subsubsection" 4)
        ("%paragraph" 5)))
   #+end_src
   Now we have to tell it what keywords to font lock
   #+begin_src emacs-lisp
   (font-lock-add-keywords
   'latex-mode
   '(("^%\\(chapter\\|\\(sub\\|subsub\\)?section\\|paragraph\\)" 0 'font-lock-keyword-face t)
   ("^%chapter{\\(.*\\)}"       1 'font-latex-sectioning-1-face t)
   ("^%section{\\(.*\\)}"       1 'font-latex-sectioning-2-face t)
   ("^%subsection{\\(.*\\)}"    1 'font-latex-sectioning-3-face t)
   ("^%subsubsection{\\(.*\\)}" 1 'font-latex-sectioning-4-face t)
   ("^%paragraph{\\(.*\\)}"     1 'font-latex-sectioning-5-face t)))
   #+end_src
* Face Attribute Changes
I really do not like using the default interface for `customize-face` so I decided to change it myself:
** Window Divider and fringes
   #+begin_src emacs-lisp
   (set-face-attribute 'window-divider nil :foreground "#282828")
   (set-face-attribute 'window-divider-first-pixel nil :foreground "#282828")
   (set-face-attribute 'window-divider-last-pixel nil :foreground "#282828")
   (set-face-attribute 'fringe nil :foreground "282828" :background "#282828")
   #+end_src
** Ivy Stuff
#+begin_src emacs-lisp
(set-face-attribute 'ivy-current-match 'nil :foreground "black" :background "#ffdd33")
#+end_src
** Org mode faces
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'org-block 'nil :foreground "#e4e4ef")
#+END_SRC
* Ease of Life
** Get to config file 
This is mostly here because on my 60% keyboard it is pretty much impossible to type the ~ key, so instead I made this function
#+begin_src emacs-lisp
(defun dotemacs () (interactive) (find-file "~/regmacs/.emacs.d/init.el"))
#+end_src
To make life easier here is also one to get to this file
#+begin_src emacs-lisp
(defun initorg () (interactive) (find-file "~/regmacs/.emacs.d/EmacsInit.org"))
#+end_src
** Get a directory for saves
This gets rid of annoying duplicate files with ~ at the end with backup data
#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs_saves")))
#+end_src
** Copy HW Files
I made this as a little project to avoid the tedium of:
   - Copying a template file into a complicated directory
   - Opening it, typing the long directory again
   - Typing repetitive section headers
So I made a pretty easy
#+begin_src emacs-lisp
(setq schoolpath "~/School/")
(setq templatepath "~/School/template.tex")
  
(defun gencopy (subj code)
  (let ((fname
         (read-file-name
         (concat subj ": ")
	     (concat schoolpath (concat code "/HW/")))))
  (copy-file templatepath fname) (find-file fname)))

(defun starthw ()
  (interactive)
  (let ((x (upcase (read-string "Class Shorthand: "))))
    (cond ((string= x "CM") (gencopy "CM" "PHYS309")) ;; Classical
  	  ((string= x "QM") (gencopy "QM" "PHYS406")) ;; UG Quantum
  	  ((string= x "EM") (gencopy "EM" "PHYS414")) ;; E&M
  	  ((string= x "MM") (gencopy "MM" "PHYS502")) ;; Grad Math Methods
  	  ((string= x "GQ") (gencopy "GQ" "PHYS510")) ;; Grad Quantum
  	  (t "failed"))))
   #+end_src
** Go to HW Files
   This uses a similar structure to copying files, but just for accessing them since I am lazy
   #+begin_src emacs-lisp
   (defun continuehw ()
     (interactive)
     (let ((x (upcase (read-string "Class Shorthand: "))))
       (cond ((string= x "CM") (find-file (concat schoolpath "/PHYS309/HW/"))) ;; Classical
  	     ((string= x "QM") (find-file (concat schoolpath "/PHYS406/HW/"))) ;; UG Quantum
  	     ((string= x "EM") (find-file (concat schoolpath "/PHYS414/HW/"))) ;; E&M
  	     ((string= x "MM") (find-file (concat schoolpath "/PHYS502/HW/"))) ;; Grad Math Methods
  	     ((string= x "GQ") (find-file (concat schoolpath "/PHYS510/HW/"))) ;; Grad Quantum
  	     (t "failed"))))
   #+end_src
* Startup
This will just be used to display startup time and with how many garbage collections
#+BEGIN_SRC emacs-lisp
(defun mpc/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                     (time-subtract after-init-time before-init-time)))
           gcs-done))


(add-hook 'emacs-startup-hook #'mpc/display-startup-time)
#+END_SRC




